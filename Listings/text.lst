C51 COMPILER V9.54   TEXT                                                                  03/08/2019 17:29:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TEXT
OBJECT MODULE PLACED IN .\Objects\text.obj
COMPILER INVOKED BY: E:\keil uVision4\C51\BIN\C51.EXE text.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\text.lst) OBJECT(.\Objects\text.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          //#include <at89x51.h>
   4          
   5          sbit LCD_RS=P1^0;//定义引脚
   6          sbit LCD_RW=P1^1;
   7          sbit LCD_E=P1^2;
   8          #define LCD_Data P2
   9          #define Busy    0x80 //用于检测LCD状态字中的Busy标识
  10          
  11          
  12          
  13          void WriteDataLCD(unsigned char WDLCD);
  14          void WriteCommandLCD(unsigned char WCLCD,BuysC);
  15          unsigned char ReadDataLCD(void);
  16          unsigned char ReadStatusLCD(void);
  17          void LCDInit(void);
  18          void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData);
  19          void DisplayListChar(unsigned char X, unsigned char Y, unsigned char code *DData);
  20          void Delay5Ms(void);
  21          void Delay400Ms(void);
  22          
  23          
  24          unsigned char code uctech[] = {"ic2012.taobao.co"};
  25          unsigned char code net[] = {"Happy every day!"};
  26          
  27          void main(void)
  28          {
  29   1       Delay400Ms(); //启动等待，等LCD讲入工作状态
  30   1       LCDInit(); //LCM初始化
  31   1       Delay5Ms(); //延时片刻(可不要)
  32   1      
  33   1       DisplayListChar(0, 0, uctech);
  34   1       //DisplayListChar(0, 5, net);
  35   1       ReadDataLCD();//测试用句无意义
  36   1       //DisplayOneChar(0x0,0x1,0x41);
  37   1              while(1);
  38   1      }
  39          
  40          //写数据
  41          void WriteDataLCD(unsigned char WDLCD)
  42          {
  43   1       ReadStatusLCD(); //检测忙
  44   1       LCD_Data = WDLCD;
  45   1       LCD_RS = 1;
  46   1       LCD_RW = 0;
  47   1       LCD_E = 0; //若晶振速度太高可以在这后加小的延时
  48   1       LCD_E = 0; //延时
  49   1       LCD_E = 1;
  50   1      }
  51          
  52          //写指令
  53          void WriteCommandLCD(unsigned char WCLCD,BuysC) //BuysC为0时忽略忙检测
  54          {
C51 COMPILER V9.54   TEXT                                                                  03/08/2019 17:29:20 PAGE 2   

  55   1       if (BuysC) ReadStatusLCD(); //根据需要检测忙
  56   1       LCD_Data = WCLCD;
  57   1       LCD_RS = 0;
  58   1       LCD_RW = 0; 
  59   1       LCD_E = 0;
  60   1       LCD_E = 0;
  61   1       LCD_E = 1; 
  62   1      }
  63          
  64          //读数据
  65          unsigned char ReadDataLCD(void)
  66          {
  67   1       LCD_RS = 1; 
  68   1       LCD_RW = 1;
  69   1       LCD_E = 0;
  70   1       LCD_E = 0;
  71   1       LCD_E = 1;
  72   1       return(LCD_Data);
  73   1      }
  74          
  75          //读状态
  76          unsigned char ReadStatusLCD(void)
  77          {
  78   1       LCD_Data = 0xFF; 
  79   1       LCD_RS = 0;
  80   1       LCD_RW = 1;
  81   1       LCD_E = 0;
  82   1       LCD_E = 0;
  83   1       LCD_E = 1;
  84   1       while (LCD_Data & Busy); //检测忙信号
  85   1       return(LCD_Data);
  86   1      }
  87          
  88          void LCDInit(void) //LCM初始化
  89          {
  90   1       LCD_Data = 0;
  91   1       WriteCommandLCD(0x38,0); //三次显示模式设置，不检测忙信号
  92   1       Delay5Ms(); 
  93   1       WriteCommandLCD(0x38,0);
  94   1       Delay5Ms(); 
  95   1       WriteCommandLCD(0x38,0);
  96   1       Delay5Ms(); 
  97   1      
  98   1       WriteCommandLCD(0x38,1); //显示模式设置,开始要求每次检测忙信号
  99   1       WriteCommandLCD(0x08,1); //关闭显示
 100   1       WriteCommandLCD(0x01,1); //显示清屏
 101   1       WriteCommandLCD(0x06,1); // 显示光标移动设置
 102   1       WriteCommandLCD(0x0C,1); // 显示开及光标设置
 103   1      }
 104          
 105          //按指定位置显示一个字符
 106          void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)
 107          {
 108   1       Y &= 0x1;
 109   1       X &= 0xF; //限制X不能大于15，Y不能大于1
 110   1       if (Y) X |= 0x40; //当要显示第二行时地址码+0x40;
 111   1       X |= 0x80; // 算出指令码
 112   1       WriteCommandLCD(X, 0); //这里不检测忙信号，发送地址码
 113   1       WriteDataLCD(DData);
 114   1      }
 115          
 116          //按指定位置显示一串字符
C51 COMPILER V9.54   TEXT                                                                  03/08/2019 17:29:20 PAGE 3   

 117          void DisplayListChar(unsigned char X, unsigned char Y, unsigned char code *DData)
 118          {
 119   1       unsigned char ListLength;
 120   1      
 121   1        ListLength = 0;
 122   1       Y &= 0x1;
 123   1       X &= 0xF; //限制X不能大于15，Y不能大于1
 124   1       while (DData[ListLength]>=0x20) //若到达字串尾则退出
 125   1        {
 126   2         if (X <= 0xF) //X坐标应小于0xF
 127   2          {
 128   3           DisplayOneChar(X, Y, DData[ListLength]); //显示单个字符
 129   3           ListLength++;
 130   3           X++;
 131   3          }
 132   2        }
 133   1      }
 134          
 135          //5ms延时
 136          void Delay5Ms(void)
 137          {
 138   1       unsigned int TempCyc = 5552;
 139   1       while(TempCyc--);
 140   1      }
 141          
 142          //400ms延时
 143          void Delay400Ms(void)
 144          {
 145   1       unsigned char TempCycA = 5;
 146   1       unsigned int TempCycB;
 147   1       while(TempCycA--)
 148   1       {
 149   2        TempCycB=7269;
 150   2        while(TempCycB--);
 151   2       };
 152   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    301    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
