C51 COMPILER V9.54   PRINT                                                                 03/08/2019 21:04:53 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PRINT
OBJECT MODULE PLACED IN .\Objects\print.obj
COMPILER INVOKED BY: E:\keil uVision4\C51\BIN\C51.EXE print.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\print.lst) OBJECT(.\Objects\print.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define LCD1602_DATA_PORT        P0
   6          typedef unsigned char u8;               // 重命名类型u8简化代码编写
   7          typedef unsigned int u16;
   8          void Lcd1602Init(void);
   9          void Lcd1602SetCursor(u8 x,u8 y);
  10          void Lcd1602ShowStr(u8 x, u8 y, u8 *pStr);
  11          sbit gLcd1602_E  = P2^7;                        // LCD1602控制总线的使能信号
  12          sbit gLcd1602_RW = P2^5;                        // LCD1602控制总线的读写选择信号
  13          sbit gLcd1602_RS = P2^6;                        // LCD1602控制总线的数据/命令选择信号
  14          sbit beep=P1^5;//蜂鸣器
  15          
  16          void T0_Init(void)
  17          {
  18   1              TMOD=0X01;    
  19   1              TH0=(65536-2000)/256;    
  20   1              TL0=(65536-2000)%256;  
  21   1              TH1=(65536-2000)/256;   
  22   1              TL1=(65536-2000)%256;   
  23   1              ET0=1;   
  24   1              ET1=1;  
  25   1              EA=1;  
  26   1              P0=0;
  27   1      }
  28          
  29          /*
  30          static void delay5ms(void);
  31          static void Lcd1602WaitNoBusy(void);
  32          static void Lcd1602WriteCmd(u8 cmd);
  33          static void Lcd1602WriteData(u8 dat); */
  34          
  35           void delay5ms(void);
  36           void Lcd1602WaitNoBusy(void);
  37           void Lcd1602WriteCmd(u8 cmd);
  38           void Lcd1602WriteData(u8 dat);
  39           
  40          static void Lcd1602WaitNoBusy(void)  //忙检测函数，判断bit7是0，允许执行；1禁止
  41          {
  42   1          u8 sta = 0;      //
  43   1      
  44   1          LCD1602_DATA_PORT = 0xff;
  45   1          gLcd1602_RS = 0;
  46   1          gLcd1602_RW = 1;
  47   1          do
  48   1          {
  49   2              gLcd1602_E = 1;
  50   2              sta = LCD1602_DATA_PORT;
  51   2              gLcd1602_E = 0;    //使能，用完就拉低，释放总线
  52   2          }while(sta & 0x80);
  53   1      }
  54          
C51 COMPILER V9.54   PRINT                                                                 03/08/2019 21:04:53 PAGE 2   

  55          static void Lcd1602WriteCmd(u8 cmd)       //按照LCD1602低层时序向LCD内部写入8位命令字
  56          {
  57   1              Lcd1602WaitNoBusy();            // 先等待LCD1602处于不忙状态
  58   1      
  59   1              gLcd1602_E = 0;                 // 禁止LCD
  60   1              gLcd1602_RS = 0;                        // 选择发送命令模式
  61   1              gLcd1602_RW = 0;                        // 选择写入模式 
  62   1              LCD1602_DATA_PORT = cmd;    // 将1字节命令字放入8位并行数据端口
  63   1              gLcd1602_E = 1;                 // 使能LED
  64   1              gLcd1602_E = 0;                         // 禁止LCD
  65   1      }
  66          
  67          static void Lcd1602WriteData(u8 dat)    //按照LCD1602低层时序向LCD内部写入8位数据               
  68          {
  69   1              Lcd1602WaitNoBusy();            // 先等待LCD1602处于不忙状态
  70   1      
  71   1              gLcd1602_E = 0;                 // 禁止LCD
  72   1              gLcd1602_RS = 1;                        // 选择发送数据模式
  73   1              gLcd1602_RW = 0;                        // 选择写入模式 
  74   1              LCD1602_DATA_PORT = dat;    // 将1字节命令字放入8位并行数据端口
  75   1              gLcd1602_E = 1;                 // 使能LED
  76   1              gLcd1602_E = 0;                         // 禁止LCD
  77   1      }
  78          
  79          void Lcd1602Init(void)          //按照LCD1602低层时序进行初始化序列                             
  80          {
  81   1              Lcd1602WriteCmd(0x38);          // 按照数据手册的初始化时序，先发送38H
  82   1              delay5ms();                                     // 延时5ms
  83   1              Lcd1602WriteCmd(0x38);          // 按照数据手册的初始化时序，先发送38H
  84   1              delay5ms();                                     // 延时5ms
  85   1              Lcd1602WriteCmd(0x38);          // 按照数据手册的初始化时序，先发送38H
  86   1              delay5ms();                                     // 延时5ms
  87   1              Lcd1602WriteCmd(0x38);          // 显示模式设置
  88   1              Lcd1602WriteCmd(0x08);          // 关闭显示
  89   1              Lcd1602WriteCmd(0x01);          // 清屏（同时清数据指针）
  90   1              Lcd1602WriteCmd(0x06);          // 读写后指针自动加1，写1个字符后整屏显示不移动
  91   1              Lcd1602WriteCmd(0x0c);          // 开显示，不显示光标
  92   1      }
  93          
  94          /*********************************************************************
  95          * 函 数 名       : Lcd1602SetCursor
  96          * 函数功能               : 本函数用来设置当前光标位置，其实就是设置当前正在编辑
  97          *                                  的位置，其实就是内部的数据地址指针，其实就是RAM显存
  98          *                                  的偏移量
  99          * 参数列表       : x - 横向坐标，范围是0-15
 100          *                                  y - 纵向坐标，0表示上面一行，1表示下面一行
 101          * 函数输出       : 无
 102          *********************************************************************/
 103          void Lcd1602SetCursor(u8 x, u8 y)       // 坐标显示
 104          {
 105   1          u8 addr = 0;
 106   1      
 107   1              switch (y)
 108   1              {
 109   2                      case 0:                                         // 上面一行
 110   2                              addr = 0x00 + x;                break;  
 111   2                      case 1:                                         // 下面一行
 112   2                              addr = 0x40 + x;                break;
 113   2                      default:
 114   2                                                                              break;
 115   2              }
 116   1          Lcd1602WriteCmd(addr | 0x80);
C51 COMPILER V9.54   PRINT                                                                 03/08/2019 21:04:53 PAGE 3   

 117   1      }
 118          
 119          
 120          /*********************************************************************
 121          * 函 数 名       : Lcd1602ShowStr
 122          * 函数功能               : 从坐标(x,y)开始显示字符串str，注意这个函数不能跨行
 123          *                                  显示，因为显存地址是不连续的。
 124          * 参数列表       : x - 横向坐标，范围是0-15
 125          *                                  y - 纵向坐标，0表示上面一行，1表示下面一行
 126          *                                  pStr - 指向待显示的字符串的指针
 127          * 函数输出       : 无
 128          *********************************************************************/
 129          void Lcd1602ShowStr(u8 x, u8 y, u8 *pStr)     //显示字符串
 130          {
 131   1          Lcd1602SetCursor(x, y);      //当前字符的坐标
 132   1          while (*pStr != '\0')
 133   1          {
 134   2              Lcd1602WriteData(*pStr++);
 135   2          }
 136   1      }
 137          
 138          
 139          
 140          /*********************************************************************
 141          * 函 数 名       : delay5ms
 142          * 函数功能               : 单片机小精灵V1.3生成的延时5ms的精确延时函数
 143          * 参数列表       : 无
 144          * 函数输出       : 无
 145          *********************************************************************/
 146          static void delay5ms(void)   //误差 0us
 147          {
 148   1          unsigned char a,b;
 149   1          for(b=19;b>0;b--)
 150   1              for(a=130;a>0;a--);
 151   1      }  
 152          int score[8];
 153          int i;
 154          int shiwei=0;
 155          int gewei=0;
 156          char bb[]="0123456789";
 157          void print(void)
 158          {
 159   1              Lcd1602Init();
 160   1              Lcd1602ShowStr(0,0,"A:00B:00C:00D:00");
 161   1              Lcd1602ShowStr(0,1,"E:00F:00G:00H:00");
 162   1              score[1]=20;
 163   1              for(i=0;i<3;i++){
 164   2              shiwei=score[i]/10;
 165   2              gewei=score[i]%10;
 166   2              Lcd1602SetCursor(2+4*i,0);
 167   2              Lcd1602WriteData(bb[shiwei]);
 168   2              Lcd1602SetCursor(3+4*i,0);
 169   2              Lcd1602WriteData(bb[gewei]);
 170   2              }
 171   1              for(i=4;i<7;i++){
 172   2              shiwei=score[i]/10;
 173   2              gewei=score[i]%10;
 174   2              Lcd1602SetCursor(2+4*(i-4),1);
 175   2              Lcd1602WriteData(bb[shiwei]);
 176   2              Lcd1602SetCursor(3+4*(i-4),1);
 177   2              Lcd1602WriteData(bb[gewei]);
 178   2              }
C51 COMPILER V9.54   PRINT                                                                 03/08/2019 21:04:53 PAGE 4   

 179   1      }
 180          //一下开始为倒计时******************************************************************
 181          int t1=0;
 182          int time=30;
 183          void timer1(void)  interrupt 3     //???1????????????(?1s)
 184          {
 185   1      TH1=(65536-2000)/256;    //???T1?8????
 186   1      TL1=(65536-2000)%256;   //???T1?8????
 187   1      beep=~beep;
 188   1      t1++;
 189   1      if(t1==500)
 190   1      {  
 191   2      t1=0;
 192   2         TR1=0;}}
 193          void delay(uchar ms)
 194                  //延时ms
 195          {
 196   1              uchar y;
 197   1              for(; ms>0;ms--)
 198   1              for(y=120;y>0;y--);
 199   1      }
 200           void main(void)
 201          {
 202   1              T0_Init();
 203   1              Lcd1602Init();
 204   1              Lcd1602ShowStr(0,0,"20:00");
 205   1              shiwei=time/10;
 206   1              gewei=time%10;
 207   1              Lcd1602SetCursor(0,0);
 208   1              Lcd1602WriteData(bb[shiwei]);
 209   1              Lcd1602SetCursor(1,0);
 210   1              Lcd1602WriteData(bb[gewei]);
 211   1      while(1)
 212   1      {
 213   2              shiwei=time/10;
 214   2              gewei=time%10;
 215   2              Lcd1602SetCursor(0,0);
 216   2              Lcd1602WriteData(bb[shiwei]);
 217   2              Lcd1602SetCursor(1,0);
 218   2              Lcd1602WriteData(bb[gewei]);
 219   2              shiwei=t1/10;
 220   2              gewei=t1%10;
 221   2              Lcd1602SetCursor(3,0);
 222   2              Lcd1602WriteData(bb[shiwei]);
 223   2              Lcd1602SetCursor(4,0);
 224   2              Lcd1602WriteData(bb[gewei]);
 225   2              if(t1==500)
 226   2              {
 227   3              time--;
 228   3              }
 229   2      }
 230   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    635    ----
   CONSTANT SIZE    =     40    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.54   PRINT                                                                 03/08/2019 21:04:53 PAGE 5   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
